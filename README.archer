A project to make remote.c not have global state, and then to make
multiple targets possible.

The remote fixes were sent upstream.

See this note for a to-do list for remote.c:

    http://sourceware.org/ml/gdb-patches/2013-06/msg00605.html

 
TO DO:

we need some kind of to_instantiate so that find_default_run_target
can work properly

fix up target-descriptions.[ch] stuff

 - must require target-async to connect to multiple
 - it would be nice if at least all targets available on
   a linux host were async-able.
   this may just prevent sim?


targets to fix:

  ctf
  tfile
  record*

  not sim -- looks too hard for now

  many others available, but not sure which are important
  also testing is an issue


seems like to_record_is_replaying could be fixed to be new-style


to_xclose stuff is wrong right now
seems like it should not free the object itself
anyway some do not free right now


DONE:
  ALL_PSPACES -vs- targets
  e.g., exec_close

fix up remove_target_sections ??
how will this interact with the BFD-sharing code?

how does breakpoint insertion work?


If user makes a new target then tries run, make sure gdb chooses the
currently-existing native target instead of trying to open a new one.

target to_name stuff should be const
but needs add_cmd


<palves_> I guess you're assuming async, right?
<palves_> need to handle same pid in different targets meaning different
	  processes.  [14:25]
<palves_> need to stop processes in all targets when one target hits event.
	  all-stop-on-top-of-non-stop gets we closer to that.  [14:26]
<palves_> gets us.
<palves_> need to iterate over all targets resuming them.
* tromey updates his notes
<tromey> yeah, I saw a similar problem with "quit", where gdb didn't ask me
	 about the running inferior  [14:27]

<palves_> which target does ctrl-c go to?
<palves_> (for synchronous commands)

<palves_> there's the whole user interface issue.  how to start a new program
	  on the same remote, vs starting a program on the different remote,
	  and how forks fit in.



It might seem like we could remove to_xclose, but that
takes a gdb_target, where to_close does not.
So we'd have to fix all to_close targets

================================================================

notes for tfile change

- we already have struct trace_status
  can we push all the data in there?

  there are some things that did not go in that struct, don't know
  why:

  -static char *trace_filename;
-static int trace_fd = -1;
-static off_t trace_frames_offset;
-static off_t cur_offset;
-static int cur_data_size;

is trace_filename redundant with trace_status?


also trace_regblock_size is a huge hack


misplaced comment:

+/* Fill in tfile_ops with its defined operations and properties.  */
+
 static void
 init_tfile_ops (void)
 {


these static variables:

 static void
trace_find_line_command (char *args, int from_tty)
{
  static CORE_ADDR start_pc, end_pc;


static void
trace_find_range_command (char *args, int from_tty)
{
  static CORE_ADDR start, stop;


should TSV numbers be per-target?



these globals:

static VEC(tsv_s) *tvariables;

/* The next integer to assign to a variable.  */

static int next_tsv_number = 1;

/* Number of last traceframe collected.  */
static int traceframe_number;

/* Tracepoint for last traceframe collected.  */
static int tracepoint_number;

/* Symbol for function for last traceframe collected.  */
static struct symbol *traceframe_fun;

/* Symtab and line for last traceframe collected.  */
static struct symtab_and_line traceframe_sal;

/* The traceframe info of the current traceframe.  NULL if we haven't
   yet attempted to fetch it, or if the target does not support
   fetching this object, or if we're not inspecting a traceframe
   presently.  */
static struct traceframe_info *traceframe_info;



