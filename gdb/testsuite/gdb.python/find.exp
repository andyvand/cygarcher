# Copyright 2008, 2009 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This tests the search_memory Python function.
# Based on the gdb.base/find.exp testcase.

if $tracelevel then {
    strace $tracelevel
}

# Usage: gdb_py_test_multiple NAME INPUT RESULT {INPUT RESULT}...
# Run a test named NAME, consisting of multiple lines of input.
# After each input line INPUT, search for result line RESULT.
# Succeed if all results are seen; fail otherwise.
proc gdb_py_test_multiple {name args} {
    global gdb_prompt
    foreach {input result} $args {
	if {[gdb_test_multiple $input "$name - $input" {
	    -re "\[\r\n\]*($result)\[\r\n\]+($gdb_prompt | *>)$" {
		pass "$name - $input"
	    }
	}]} {
	    return 1
	}
    }
    return 0
}

set testfile "find"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug nowarnings}] != "" } {
    untested find.exp
    return -1
}

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

gdb_test_multiple "python print 'hello, world!'" "verify python support" {
    -re "not supported.*$gdb_prompt $"	{
      unsupported "python support is disabled"
      return -1
    }
    -re "$gdb_prompt $"	{}
}

gdb_test "break $srcfile:stop_here" \
    "Breakpoint.*at.* file .*$srcfile, line.*" \
    "breakpoint function in file"

gdb_run_cmd
gdb_expect {
    -re "Breakpoint \[0-9\]+,.*stop_here.* at .*$srcfile:.*$gdb_prompt $" {
	pass "run until function breakpoint"
    }
    -re "$gdb_prompt $" {
	fail "run until function breakpoint"
    }
    timeout {
	fail "run until function breakpoint (timeout)"
    }
}

# We've now got the target program in a state where we can test "find".

set hex_number {0x[0-9a-fA-F][0-9a-fA-F]*}
set dec_number {[0-9]+}
set history_prefix {[$][0-9]* = }
set newline {[\r\n]+}
set pattern_not_found "${newline}.]"
set one_pattern_found "${newline}.${dec_number}L]"
set two_patterns_found "${newline}.${dec_number}L, ${dec_number}L]"

# Test string pattern.

gdb_test "set *(int32_t*) &int8_search_buf\[10\] = 0x61616161" "" ""
gdb_test "py start_addr = gdb.parse_and_eval ('&int8_search_buf\[0\]')" "" ""
gdb_test "py length = gdb.parse_and_eval ('sizeof (int8_search_buf)')" "" ""

gdb_test "py print gdb.search_memory (start_addr, length, 'aaa')" \
  "${two_patterns_found}" "find string pattern"

# Test not finding pattern because search range too small, with
# potential find at the edge of the range.

gdb_test "py print gdb.search_memory (start_addr, 10+3, 'aaaa')" \
  "${pattern_not_found}" "pattern not found at end of range"

# Increase the search range by 1 and we should find the pattern.

gdb_test "py print gdb.search_memory (start_addr, 10+3+1, \['a', 'a', 'a', 'a'\])" \
  "${one_pattern_found}" "pattern found at end of range"

# Test max-count with size-char.

gdb_test "py print gdb.search_memory (start_addr, length, \[0x61, 0x61\], 1, 1)" \
  "\[\\r\\n\].${dec_number}L]" "size = 1, max_count = 1"

# Test 16-bit pattern.

gdb_test "set int16_search_buf\[10\] = 0x1234" "" ""
gdb_test "py start_addr = gdb.parse_and_eval ('&int16_search_buf\[0\]')" "" ""
gdb_test "py length = gdb.parse_and_eval ('sizeof (int16_search_buf)')" "" ""
gdb_test "py pattern = gdb.parse_and_eval ('(int16_t) 0x1234')" "" ""

gdb_test "py print gdb.search_memory (start_addr, length, 0x1234, 2)" \
  "${one_pattern_found}" "find 16-bit pattern, with python pattern"

gdb_test "py print gdb.search_memory (start_addr, length, pattern)" \
  "${one_pattern_found}" "find 16-bit pattern, with value pattern"

# Test 32-bit pattern.

gdb_test "set int32_search_buf\[10\] = 0x12345678" "" ""
gdb_test "py start_addr = gdb.parse_and_eval ('&int32_search_buf\[0\]')" "" ""
gdb_test "py length = gdb.parse_and_eval ('sizeof (int32_search_buf)')" "" ""
gdb_test "py pattern = gdb.parse_and_eval ('(int32_t) 0x12345678')" "" ""

gdb_test "py print gdb.search_memory (start_addr, length, 0x12345678, 4)" \
  "${one_pattern_found}" "find 32-bit pattern, with python pattern"
gdb_test "py print gdb.search_memory (start_addr, length, pattern)" \
  "${one_pattern_found}" "find 32-bit pattern, with value pattern"

# Test 64-bit pattern.

gdb_test "set int64_search_buf\[10\] = 0xfedcba9876543210LL" "" ""
gdb_test "py start_addr = gdb.parse_and_eval ('&int64_search_buf\[0\]')" "" ""
gdb_test "py length = gdb.parse_and_eval ('sizeof (int64_search_buf)')" "" ""
gdb_test "py pattern = gdb.parse_and_eval ('(int64_t) 0xfedcba9876543210LL')" "" ""

gdb_test "py print gdb.search_memory (start_addr, length, 0xfedcba9876543210, 8)" \
  "${one_pattern_found}" "find 64-bit pattern, with python pattern"
gdb_test "py print gdb.search_memory (start_addr, length, pattern)" \
  "${one_pattern_found}" "find 64-bit pattern, with value pattern"

# Test mixed-sized patterns.

gdb_test "set *(int8_t*) &search_buf\[10\] = 0x62" "" ""
gdb_test "set *(int16_t*) &search_buf\[11\] = 0x6363" "" ""
gdb_test "set *(int32_t*) &search_buf\[13\] = 0x64646464" "" ""
gdb_test "py start_addr = gdb.parse_and_eval ('&search_buf\[0\]')" "" ""
gdb_test "py pattern1 = gdb.parse_and_eval ('(int8_t) 0x62')" "" ""
gdb_test "py pattern2 = gdb.parse_and_eval ('(int16_t) 0x6363')" "" ""
gdb_test "py pattern3 = gdb.parse_and_eval ('(int32_t) 0x64646464')" "" ""

gdb_test "py print gdb.search_memory (start_addr, 100, \[pattern1, pattern2, pattern3\])" \
    "${one_pattern_found}" "find mixed-sized pattern"

# Test search spanning a large range, in the particular case of native
# targets, test the search spanning multiple chunks.
# Remote targets may implement the search differently.

set CHUNK_SIZE 16000 ;

gdb_test "set *(int32_t*) &search_buf\[0*${CHUNK_SIZE}+100\] = 0x12345678" "" ""
gdb_test "set *(int32_t*) &search_buf\[1*${CHUNK_SIZE}+100\] = 0x12345678" "" ""
gdb_test "py start_addr = gdb.parse_and_eval ('search_buf')" "" ""
gdb_test "py length = gdb.parse_and_eval ('search_buf_size')" "" ""

gdb_test "py print gdb.search_memory (start_addr, length, 0x12345678, 4)" \
  "${two_patterns_found}" "search spanning large range"

# For native targets, test a pattern straddling a chunk boundary.

if [isnative] {
    gdb_test "set *(int32_t*) &search_buf\[${CHUNK_SIZE}-1\] = 0xfdb97531" "" ""

    gdb_test "py print gdb.search_memory (start_addr, length, 0xfdb97531, 4)" \
      "${one_pattern_found}" "find pattern straddling chunk boundary"
}
